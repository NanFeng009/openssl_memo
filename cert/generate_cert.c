/*
 *# create a self-signed certificate
 *openssl req -new -x509 -key pri.pem -out cert.pem -days 360
 *# pri.pem is generated by ../key.c
 *
 */
/*
 * gcc cert.c -lcrypto -DCUSTOM_EXT
 */
#include <stdio.h>
#include <string.h>
#include <openssl/asn1.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#define KEY_PUBLIC  0
#define KEY_PRIVATE 1

/*
 * Add extension using V3 code: we can set the config file as NULL because we
 * wont reference any other sections.
 */

int add_ext(X509 *cert, int nid, char *value)
{
	X509_EXTENSION *ex;
	X509V3_CTX ctx;
	/* This sets the 'context' of the extensions. */
	/* No configuration database */
	X509V3_set_ctx_nodb(&ctx);
	/*
	 * Issuer and subject certs: both the target since it is self signed, no
	 * request and no CRL
	 */
	X509V3_set_ctx(&ctx, cert, cert, NULL, NULL, 0);
	ex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);
	if (!ex)
		return 0;

	X509_add_ext(cert, ex, -1);
	X509_EXTENSION_free(ex);
	return 1;
}


int key_load_from_file(EVP_PKEY **key, const char* filename, int keytype)
{
	FILE* fp;
	*key = EVP_PKEY_new();

	if((fp = fopen(filename, "r")) == NULL) {
		printf("error in open key file\n");
		return -1;
	}
	if(keytype == KEY_PRIVATE) PEM_read_PrivateKey(fp, key, NULL, NULL);
	else if(keytype == KEY_PUBLIC) PEM_read_PUBKEY(fp, key, NULL, NULL);
	else {
		printf("wrong key type\n");
		return -1;
	}

	fclose(fp);

	return 0;
}

int main(int argc, char** argv)
{
	EVP_PKEY* private_key = NULL;
	X509* x509cert = NULL;
	X509_NAME* name = NULL;
	int ret;

	ret = key_load_from_file(&private_key, "../key/pri.pem", KEY_PRIVATE);

	x509cert = X509_new();
	if (x509cert == NULL)
		return -1;
	// set version to V3
	if (!X509_set_version(x509cert, 2))
		return -1;
	// set key
	if (!X509_set_pubkey(x509cert, private_key))
		return -1;
	// set subject&issuer name
	name = X509_NAME_new();
	if (!X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_UTF8, (const unsigned char*) "Intel SGX Enclave", -1, -1, 0))
		return -1; 
	if (!X509_NAME_add_entry_by_txt(name, "O", MBSTRING_UTF8, (const unsigned char*) "Intel Corporation", -1, -1, 0))
		return -1;
	if (!X509_NAME_add_entry_by_txt(name, "C", MBSTRING_UTF8, (const unsigned char*) "US", -1, -1, 0))
		return -1;
	X509_set_subject_name(x509cert, name);
	X509_set_issuer_name(x509cert, name);
	X509_NAME_free(name);
	name = NULL;

	// set serial number
	ret = ASN1_INTEGER_set(X509_get_serialNumber(x509cert), 1);

	// set validity from&to date(fromat YYYMMDDHHMMSSZ)
	ret = ASN1_TIME_set_string(X509_getm_notBefore(x509cert), "184006201020Z");
	ret = ASN1_TIME_set_string(X509_getm_notAfter(x509cert), "205006201020Z");

	/*
	 * add the extension
	 */
#ifdef CUSTOM_EXT
	add_ext(x509cert, NID_basic_constraints, "CA:FALSE");
	add_ext(x509cert, NID_subject_key_identifier, "hash");
	add_ext(x509cert, NID_authority_key_identifier, "keyid:always");
	// add custom extension
	X509_EXTENSION *ex;
	ASN1_OCTET_STRING* data;
	ASN1_OBJECT* obj;
	data = ASN1_OCTET_STRING_new();
	ret = ASN1_OCTET_STRING_set(
			data,
			(const unsigned char*)"Hello world",
			strlen("Hello world")
			);
	obj = OBJ_txt2obj("1.3.6.1.1.311.105.1", 1);
	ex = X509_EXTENSION_create_by_OBJ(NULL, obj, 0, data);
	X509_add_ext(x509cert, ex, -1);
	ASN1_OBJECT_free(obj);
	X509_EXTENSION_free(ex);
	ASN1_OCTET_STRING_free(data);
#endif //CUSTOM_EXT

	// sign the x509 certificate
	if (!X509_sign(x509cert, private_key, EVP_sha1()))
		return -1;


	//write cert in PEM format to stdout
	BIO* out = BIO_new_fp(stdout, 0 /* don't close */);
	PEM_write_bio_X509(out, x509cert);
	BIO_free(out);

	/*
	 * free object
	 */
	X509_free(x509cert);
	X509_NAME_free(name);
	EVP_PKEY_free(private_key);
}
